

/**可以序列化为JSON文件的对象 */
export type JToken = JObject|JArray|JValue|IJData;
/**在stringify输出时 undefine 会被转为 null */
export type JValue = number|string|boolean|null|undefined;
/**在stringify输出时 值为 undefine 的成员会被转为 null */
export type JArray = Array<JToken>;
/**在stringify输出时 值为 undefine 的键会被忽略 */
export type JObject = {
    [key:string]:JToken;
}
/**可以保存为JToken的类 */
export interface IJData{
	/**保存为JToken
	 */
	toJSON():JToken;
}
/**将JToken转换为字符串
 * @param {JToken|IJData} token - 待转换的Token
 * @param {string|number|null} space - 插入的空格 数字为空格数量 默认为制表符\t
 * @returns 转换完成的字符串
 */
export function stringifyJToken(token:JToken|IJData,space:string|number|null|undefined="\t"){
	if(space==null)
		space=undefined;
	return JSON.stringify(token,null,space);
}

/**转为可写的 */
export type Writeable<T> = {
	-readonly [P in keyof T]: T[P]
};
/**翻转K和V */
export type Inverted<T extends Record<keyof T, string | number | symbol>> = {
    [K in keyof T as T[K]]: K;
};
/**N长度 T类型的元组  */
export type FixedLengthTuple<T, N extends number, R extends unknown[] = []> =
    R['length'] extends N ? R : FixedLengthTuple<T, N, [T, ...R]>;


/**不影响智能补全的任意字符串
 * (string&Object)
 * (string&String)
 */
export type AnyString = (string&{});



/**创建一个新的类型，这个新的类型包含了基础类型 B 的所有属性，
 * 以及一个名为 K[N] 类型为 T 的新属性。
 * 所有 K 中非 K[N] 的其他属性都是可选的并且不能被赋值（因为它们的类型是 never）。
 */
type ExclusiveSub<B, T, K extends string[], N extends number> =
    B & { [P in K[N]]: T } & { [P in Exclude<K[number], K[N]>]?: never };

/**递归地创建一个元组类型, 所有成员类型都有一个 K[number] 键 并且与其他成员互斥
 * 这个元组类型的每个元素都是通过 ExclusiveSub 类型创建的。
 */
type ExclusiveRecursive<B, T, K extends string[], R extends unknown[] = []> =
    R['length'] extends K['length'] ? R
    : ExclusiveRecursive<B, T, K, [ExclusiveSub<B, T, K, R['length']>, ...R]>;

/**互斥表
 * 从 ExclusiveRecursive 类型创建的元组中创建一个或类型, 可以是任意一个元组元素类型
 */
export type ExclusiveRecord<B, T, K extends string[], TMP = ExclusiveRecursive<B, T, K>> = TMP[keyof TMP];

/**符合JObject约束的互斥表 */
export type ExclusiveJObject<B extends JObject,T extends JToken,K extends string[],
    TMP extends JArray = ExclusiveRecursive<B,T,K>> = TMP[number];


/**请求完成状态 成功/失败/终止  
 * 成功/终止 将直接返回  
 * 失败 将重试  
 */
export type PromiseStat = "Completed"|"Failed"|"Terminated";
/**promise验证函数 */
export type PromiseVerifyFn<T> = (obj:T)=>Promise<PromiseStat>|PromiseStat;
/**发起promise的函数 */
export type PromiseProcFn<T> = ()=>Promise<T>;