import * as crypto from "crypto";
import { JToken, PromiseProcFn, PromiseStat, PromiseVerifyFn } from "./UtilInterfaces";
import * as cp from "child_process";
import { SLogger } from "./UtilLogger";

/**常用函数 */
export namespace UtilFunc{
/**获取当前时间戳  
 * number ()  
 * @returns {number} 时间戳
 */
export function getTime(): number {
    return new Date().getTime();
}

/**初始化对象的字段  
 * void (Object,string,any)  
 * @param {Record<string,T>} obj   - 所要初始化的对象
 * @param {string} field 		   - 所要初始化的字段
 * @param {T} defaultVal 		   - 默认值
 * @returns {T} - 最终值
 */
export function initField<T>(
    obj: Record<string, T>,
    field: string,
    defaultVal: T
): T {
    if (!(field in obj)) obj[field] = defaultVal;
    return obj[field];
}

/**生成一串uuid  
 * string ()  
 * @returns {string} uuid
 */
export function genUUID() {
    return crypto.randomBytes(16).toString("hex");
}
/**计算Hash  
 * string ()  
 * @param {string} str - 待计算的字符串
 * @returns {string} hash
 */
export function calcHash(str:string) {
    return crypto.createHash('md5').update(str).digest('hex');
}

/**深克隆 序列化并反序列化  
 * @template {T} T - JToken类型的泛型
 * @param {T} obj - 克隆目标
 * @returns {T}   克隆结果
 */
export function deepClone<T extends JToken>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
}

/**是否为安全的数字
 * @param {number} num - 所要检测的数字
 * @returns {boolean} 是否安全
 */
export function isSafeNumber(num: number): boolean {
    if (num === undefined || num == null || isNaN(num)) return false;
    if(typeof num === 'number') return true;
    return false;
}

/**等待 timeMs 毫秒  
 * @async
 * @param {number} timeMs - 等待的毫秒数
 * @returns {Promise<boolean>}
 */
export async function sleep(timeMs: number): Promise<boolean> {
    return new Promise(function (resolve, rejecte) {
        let timer = setTimeout(function () {
            resolve(true);
        }, timeMs);
    });
}

/**封装的 cp.exec 执行一段指令 指令完成后返回 Promise  
 * @param {string} command 指令文本
 */
export function exec(command: string) {
	return new Promise<{ stdout:string, stderr:string }>
        ((resolve, reject) => {
		cp.exec(command, (error, stdout, stderr) => {
			if (error)
				reject(error);
			else
				resolve({ stdout, stderr });
		});
	});
}

const NeverResolvedPromise = new Promise(()=>{});
/**获得一个永不完成的Promise单例 */
export function getNeverResolvedPromise<T>():Promise<T>{
    return NeverResolvedPromise as Promise<T>;
}

/**进行中的请求 */
type ProcessingPromise<T> = {
    /**主体请求 */
    result:T;
    /**请求状态 */
    stat:PromiseStat|Promise<PromiseStat>;
    /**请求下标/序号 */
    index:number;
};

/**重复尝试promise  
 * @async
 * @param {PromiseProcFn<T>} [procFn]       - 发起函数
 * @param {PromiseVerifyFn<T>} [verifyFn]   - 验证函数
 * @param {number} [repeatCount]    - 重试次数
 * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
 * @returns {Promise<T|null>}       - 结果 null 为全部失败/超时
 */
export async function repeatPromise<T>(procFn:PromiseProcFn<T>,verifyFn?:PromiseVerifyFn<T>,
    repeatCount:number=3,repeatTime:number=180):Promise<T|null>{

    //计时
    const timeflag = "repeatPromise "+UtilFunc.genUUID();
    SLogger.time(timeflag);

    //转换为毫秒
    const hasRepeatTime = (repeatTime>=10);
    if(hasRepeatTime) repeatTime*=1000;

    //验证处理函数
    if(verifyFn===undefined)
        verifyFn = ()=>"Completed";

    //计时器
    let timer:NodeJS.Timer|null = null;
    let timerP:Promise<"Timeout">|null=null;
    let resolveFn:((value: "Timeout" | PromiseLike<"Timeout">)=>void)|null = null;
    /**清理计时器 */
    const clearTimer = ()=>{
        if(timer!=null)
            clearInterval(timer);
        if(resolveFn!=null)
            resolveFn("Timeout");
        timerP=null;
        timer=null;
        resolveFn=null;
    }

    //进行中的请求
	const plist:Promise<ProcessingPromise<T>>[] = [];

    //开始处理
    try{
        for(let i=0;i<repeatCount;){
            SLogger.info(`开始第 ${i+1} 次 repeatPromise`);
            //创建当前任务
            if(plist.length<i+1){
                plist.push(procFn().then(result =>
                    ({result, stat:verifyFn!(result), index:i})));
            }

            //创建定时器
            if(timerP==null){
                timerP = new Promise<"Timeout">(function(resolve, rejecte){
                    resolveFn = resolve;
                    timer = setTimeout(()=>resolve("Timeout"),
                        hasRepeatTime? repeatTime:Infinity);//无限制则无限时间
                })
            }

            //等待完成
            const currObj = await Promise.race([...plist, timerP]);

            //超时处理
            if(currObj=="Timeout"){
                SLogger.warn(`第 ${i+1} 次 repeatPromise 超时 ${repeatTime} ms 开始重试`);
                clearTimer(); i++;
                continue;
            }
            const poststat = await currObj.stat;
            switch(poststat){
                case "Completed"://完成
                    SLogger.info(`第 ${currObj.index+1} 次 repeatPromise 成功`);
                    //非当前
                    if(currObj.index!=i)
                        SLogger.info(`成功的 promise 非当前 promise 考虑增大重试间隔\n当前index: ${i}\n当前间隔: ${repeatTime}`);
                    return currObj.result;
                case "Terminated"://终止
                    SLogger.warn(`第 ${currObj.index+1} 次 repeatPromise 终止 停止重试`);
                    return currObj.result;
                case "Failed"://验证失败
                    //抛弃失败
                    plist[currObj.index] = UtilFunc.getNeverResolvedPromise();
                    //是当前
                    if(currObj.index==i){
                        SLogger.warn(`第 ${currObj.index+1} 次 repeatPromise 失败 开始重试`);
                        clearTimer(); i++;
                        continue;
                    }
                    //非当前
                    SLogger.warn(`第 ${currObj.index+1} 次 repeatPromise 失败`);
                    continue;
            }
        }
        //全部失败或超时则返回null
        SLogger.warn(`${repeatCount} 次 repeatPromise 尝试均失败`);
        return null;
    }catch(err){
        SLogger.warn(`repeatPromise 发生错误`,err);
        return null;
    }finally{
        //清理
        clearTimer();
        SLogger.timeEnd(timeflag);
    }
}

}

