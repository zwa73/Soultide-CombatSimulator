"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilCom = void 0;
const UtilInterfaces_1 = require("./UtilInterfaces");
const https = require("https");
const http = require("http");
const UtilLogger_1 = require("./UtilLogger");
const UtilFunctions_1 = require("./UtilFunctions");
/**网络工具 */
var UtilCom;
(function (UtilCom) {
    /**通用post处理
     * @param {"http"|"https"} posttype - post类型
     * @param {JObject} json 	        - 数据对象
     * @param {Object} options          - 参数对象
     * @param {number} [timeLimit]      - 超时时间/秒  最小为10秒
     * @returns {Promise<JObject|null>} 结果 null 为未能成功接收
     */
    function sPost(posttype, json, options, timeLimit = -1) {
        //转换为毫秒
        const hasTimeLimit = (timeLimit >= 10);
        if (hasTimeLimit)
            timeLimit *= 1000;
        const jsonStr = (0, UtilInterfaces_1.stringifyJToken)(json);
        const funcName = "s" + posttype + "Psot";
        return new Promise((resolve, rejecte) => {
            const resFunc = (res) => {
                try {
                    //请求超时
                    if (hasTimeLimit) {
                        res.setTimeout(timeLimit, () => {
                            //res.abort();
                            UtilLogger_1.SLogger.warn(funcName + " 接收反馈超时: " + timeLimit + " ms");
                            resolve(null);
                            return;
                        });
                    }
                    let resdata = "";
                    res.setEncoding('utf8');
                    res.on('data', (chunk) => resdata += chunk);
                    res.on('error', (e) => {
                        UtilLogger_1.SLogger.warn(funcName + " 接收反馈错误:" + e);
                        resolve(null);
                        return;
                    });
                    res.on('end', () => {
                        if (resdata == "") {
                            UtilLogger_1.SLogger.warn(funcName + " 接收反馈错误: resdata 为空");
                            resolve(null);
                            return;
                        }
                        try {
                            let obj = JSON.parse(resdata);
                            UtilLogger_1.SLogger.http(funcName + " 接受信息:", (0, UtilInterfaces_1.stringifyJToken)(obj));
                            resolve(obj);
                            return;
                        }
                        catch (e) {
                            UtilLogger_1.SLogger.warn(funcName + " 接收反馈错误:" + e + "\n原始字符串:" + resdata);
                            resolve(null);
                            return;
                        }
                    });
                }
                catch (err) {
                    UtilLogger_1.SLogger.warn(funcName + " 未知错误:" + err);
                    resolve(null);
                    return;
                }
            };
            //路由 http/https
            let req = null;
            if (posttype === "https")
                req = https.request(options, resFunc);
            else if (posttype === "http")
                req = http.request(options, resFunc);
            //请求超时
            if (hasTimeLimit) {
                req.setTimeout(timeLimit, () => {
                    UtilLogger_1.SLogger.warn(funcName + " 发送请求超时: " + timeLimit + " ms");
                    req.destroy();
                });
            }
            req.on('error', (e) => {
                UtilLogger_1.SLogger.warn(funcName + " 发送请求错误:" + e);
                resolve(null);
            });
            req.write(jsonStr);
            req.end();
        });
    }
    /**发送一个 https POST请求并接受数据
     * Object ()
     * @async
     * @param {JObject} json 	   - 数据对象
     * @param {Object} options     - 参数对象
     * @param {number} [timeLimit] - 超时时间/秒  最小为10秒
     * @returns {Promise<JObject|null>} 结果 null 为未能成功接收
     */
    function shttpsPost(json, options, timeLimit = -1) {
        return sPost("https", json, options, timeLimit);
    }
    UtilCom.shttpsPost = shttpsPost;
    /**发送一个 http POST请求并接受数据
     * Object ()
     * @async
     * @param {JObject} json 	   - 数据对象
     * @param {Object} options     - 参数对象
     * @param {number} [timeLimit] - 超时时间/秒  最小为10秒
     * @returns {Promise<JObject|null>} 结果 null 为未能成功接收
     */
    function shttpPost(json, options, timeLimit = -1) {
        return sPost("http", json, options, timeLimit);
    }
    UtilCom.shttpPost = shttpPost;
    /**通用重复post处理
     * @async
     * @param {"http"|"https"} posttype - post类型
     * @param {JObject} json 	        - 数据对象
     * @param {Object} options          - 参数对象
     * @param {number} [timeLimit]      - 超时时间/秒  最小为10秒
     * @param {number} [repeatCount]    - 重试次数
     * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
     * @param {PromiseVerifyFn<JObject|null>} [verifyFn]     - 判断有效性函数
     * @returns {Promise<JObject|null>}  - 结果 null 为未能成功接收
     */
    async function sRepeatPost(posttype, json, options, timeLimit = -1, repeatCount = 3, repeatTime = 180, verifyFn) {
        const procFn = () => sPost(posttype, json, options, timeLimit);
        return UtilFunctions_1.UtilFunc.repeatPromise(procFn, verifyFn, repeatCount, repeatTime);
    }
    /**重复一个 https POST请求并接受数据
     * Object ()
     * @async
     * @param {JObject} json 	        - 数据对象
     * @param {Object} options          - 参数对象
     * @param {number} [timeLimit]      - 超时时间/秒  最小为10秒
     * @param {number} [repeatCount]    - 重试次数
     * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
     * @param {PromiseVerifyFn<JObject|null>} [verifyFn]     - 判断有效性函数
     * @returns {Promise<JObject|null>}  - 结果 null 为未能成功接收
     */
    function shttpsRepeatPost(json, options, timeLimit = -1, repeatCount = 3, repeatTime = 180, verifyFn) {
        return sRepeatPost("https", json, options, timeLimit, repeatCount, repeatTime, verifyFn);
    }
    UtilCom.shttpsRepeatPost = shttpsRepeatPost;
    /**重复一个 http POST请求并接受数据
     * Object ()
     * @async
     * @param {JObject} json 	        - 数据对象
     * @param {Object} options          - 参数对象
     * @param {number} [timeLimit]      - 超时时间/秒  最小为10秒
     * @param {number} [repeatCount]    - 重试次数
     * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
     * @param {PromiseVerifyFn<JObject|null>} [verifyFn]     - 判断有效性函数
     * @returns {Promise<JObject|null>}  - 结果 null 为未能成功接收
     */
    function shttpRepeatPost(json, options, timeLimit = -1, repeatCount = 3, repeatTime = 180, verifyFn) {
        return sRepeatPost("http", json, options, timeLimit, repeatCount, repeatTime, verifyFn);
    }
    UtilCom.shttpRepeatPost = shttpRepeatPost;
})(UtilCom = exports.UtilCom || (exports.UtilCom = {}));
