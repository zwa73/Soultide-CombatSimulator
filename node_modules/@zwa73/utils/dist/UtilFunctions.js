"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sleep = exports.isSafeNumber = exports.deepClone = exports.calcHash = exports.genUUID = exports.initField = exports.getTime = void 0;
const crypto = require("crypto");
/**获取当前时间戳
 * number ()
 * @returns {number} 时间戳
 */
function getTime() {
    return new Date().getTime();
}
exports.getTime = getTime;
/**初始化对象的字段
 * void (Object,string,any)
 * @param {Record<string,T>} obj   - 所要初始化的对象
 * @param {string} field 		   - 所要初始化的字段
 * @param {T} defaultVal 		   - 默认值
 * @returns {T} - 最终值
 */
function initField(obj, field, defaultVal) {
    if (!(field in obj))
        obj[field] = defaultVal;
    return obj[field];
}
exports.initField = initField;
/**生成一串uuid
 * string ()
 * @returns {string} uuid
 */
function genUUID() {
    return crypto.randomBytes(16).toString("hex");
}
exports.genUUID = genUUID;
/**计算Hash
 * string ()
 * @param {string} str - 待计算的字符串
 * @returns {string} hash
 */
function calcHash(str) {
    return crypto.createHash('md5').update(str).digest('hex');
}
exports.calcHash = calcHash;
/**深克隆 序列化并反序列化
 * @template {T} T - JToken类型的泛型
 * @param {T} obj - 克隆目标
 * @returns {T}   克隆结果
 */
function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.deepClone = deepClone;
/**是否为安全的数字
 * @param {number} num - 所要检测的数字
 * @returns {boolean} 是否安全
 */
function isSafeNumber(num) {
    if (num === undefined || num == null || isNaN(num))
        return false;
    if (typeof num === 'number')
        return true;
    return false;
}
exports.isSafeNumber = isSafeNumber;
/**等待 timeMs 毫秒
 * @async
 * @param {number} timeMs - 等待的毫秒数
 * @returns {Promise<boolean>}
 */
async function sleep(timeMs) {
    return new Promise(function (resolve, rejecte) {
        let timer = setTimeout(function () {
            resolve(true);
        }, timeMs);
    });
}
exports.sleep = sleep;
