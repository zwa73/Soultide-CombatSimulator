"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UtilFunc = void 0;
const crypto = require("crypto");
const cp = require("child_process");
const UtilLogger_1 = require("./UtilLogger");
/**常用函数 */
var UtilFunc;
(function (UtilFunc) {
    /**获取当前时间戳
     * number ()
     * @returns {number} 时间戳
     */
    function getTime() {
        return new Date().getTime();
    }
    UtilFunc.getTime = getTime;
    /**初始化对象的字段
     * void (Object,string,any)
     * @param {Record<string,T>} obj   - 所要初始化的对象
     * @param {string} field 		   - 所要初始化的字段
     * @param {T} defaultVal 		   - 默认值
     * @returns {T} - 最终值
     */
    function initField(obj, field, defaultVal) {
        if (!(field in obj))
            obj[field] = defaultVal;
        return obj[field];
    }
    UtilFunc.initField = initField;
    /**生成一串uuid
     * string ()
     * @returns {string} uuid
     */
    function genUUID() {
        return crypto.randomBytes(16).toString("hex");
    }
    UtilFunc.genUUID = genUUID;
    /**计算Hash
     * string ()
     * @param {string} str - 待计算的字符串
     * @returns {string} hash
     */
    function calcHash(str) {
        return crypto.createHash('md5').update(str).digest('hex');
    }
    UtilFunc.calcHash = calcHash;
    /**深克隆 序列化并反序列化
     * @template {T} T - JToken类型的泛型
     * @param {T} obj - 克隆目标
     * @returns {T}   克隆结果
     */
    function deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    }
    UtilFunc.deepClone = deepClone;
    /**是否为安全的数字
     * @param {number} num - 所要检测的数字
     * @returns {boolean} 是否安全
     */
    function isSafeNumber(num) {
        if (num === undefined || num == null || isNaN(num))
            return false;
        if (typeof num === 'number')
            return true;
        return false;
    }
    UtilFunc.isSafeNumber = isSafeNumber;
    /**等待 timeMs 毫秒
     * @async
     * @param {number} timeMs - 等待的毫秒数
     * @returns {Promise<boolean>}
     */
    async function sleep(timeMs) {
        return new Promise(function (resolve, rejecte) {
            let timer = setTimeout(function () {
                resolve(true);
            }, timeMs);
        });
    }
    UtilFunc.sleep = sleep;
    /**封装的 cp.exec 执行一段指令 指令完成后返回 Promise
     * @param {string} command 指令文本
     */
    function exec(command) {
        return new Promise((resolve, reject) => {
            cp.exec(command, (error, stdout, stderr) => {
                if (error)
                    reject(error);
                else
                    resolve({ stdout, stderr });
            });
        });
    }
    UtilFunc.exec = exec;
    const NeverResolvedPromise = new Promise(() => { });
    /**获得一个永不完成的Promise单例 */
    function getNeverResolvedPromise() {
        return NeverResolvedPromise;
    }
    UtilFunc.getNeverResolvedPromise = getNeverResolvedPromise;
    /**重复尝试promise
     * @async
     * @param {PromiseProcFn<T>} [procFn]       - 发起函数
     * @param {PromiseVerifyFn<T>} [verifyFn]   - 验证函数
     * @param {number} [repeatCount]    - 重试次数
     * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
     * @returns {Promise<T|null>}       - 结果 null 为全部失败/超时
     */
    async function repeatPromise(procFn, verifyFn, repeatCount = 3, repeatTime = 180) {
        //计时
        const timeflag = "repeatPromise " + UtilFunc.genUUID();
        UtilLogger_1.SLogger.time(timeflag);
        //转换为毫秒
        const hasRepeatTime = (repeatTime >= 10);
        if (hasRepeatTime)
            repeatTime *= 1000;
        //验证处理函数
        if (verifyFn === undefined)
            verifyFn = () => "Completed";
        //计时器
        let timer = null;
        let timerP = null;
        let resolveFn = null;
        /**清理计时器 */
        const clearTimer = () => {
            if (timer != null)
                clearInterval(timer);
            if (resolveFn != null)
                resolveFn("Timeout");
            timerP = null;
            timer = null;
            resolveFn = null;
        };
        //进行中的请求
        const plist = [];
        //开始处理
        try {
            for (let i = 0; i < repeatCount;) {
                UtilLogger_1.SLogger.info(`开始第 ${i + 1} 次 repeatPromise`);
                //创建当前任务
                if (plist.length < i + 1) {
                    plist.push(procFn().then(result => ({ result, stat: verifyFn(result), index: i })));
                }
                //创建定时器
                if (timerP == null) {
                    timerP = new Promise(function (resolve, rejecte) {
                        resolveFn = resolve;
                        timer = setTimeout(() => resolve("Timeout"), hasRepeatTime ? repeatTime : Infinity); //无限制则无限时间
                    });
                }
                //等待完成
                const currObj = await Promise.race([...plist, timerP]);
                //超时处理
                if (currObj == "Timeout") {
                    UtilLogger_1.SLogger.warn(`第 ${i + 1} 次 repeatPromise 超时 ${repeatTime} ms 开始重试`);
                    clearTimer();
                    i++;
                    continue;
                }
                const poststat = await currObj.stat;
                switch (poststat) {
                    case "Completed": //完成
                        UtilLogger_1.SLogger.info(`第 ${currObj.index + 1} 次 repeatPromise 成功`);
                        //非当前
                        if (currObj.index != i)
                            UtilLogger_1.SLogger.info(`成功的 promise 非当前 promise 考虑增大重试间隔\n当前index: ${i}\n当前间隔: ${repeatTime}`);
                        return currObj.result;
                    case "Terminated": //终止
                        UtilLogger_1.SLogger.warn(`第 ${currObj.index + 1} 次 repeatPromise 终止 停止重试`);
                        return currObj.result;
                    case "Failed": //验证失败
                        //抛弃失败
                        plist[currObj.index] = UtilFunc.getNeverResolvedPromise();
                        //是当前
                        if (currObj.index == i) {
                            UtilLogger_1.SLogger.warn(`第 ${currObj.index + 1} 次 repeatPromise 失败 开始重试`);
                            clearTimer();
                            i++;
                            continue;
                        }
                        //非当前
                        UtilLogger_1.SLogger.warn(`第 ${currObj.index + 1} 次 repeatPromise 失败`);
                        continue;
                }
            }
            //全部失败或超时则返回null
            UtilLogger_1.SLogger.warn(`${repeatCount} 次 repeatPromise 尝试均失败`);
            return null;
        }
        catch (err) {
            UtilLogger_1.SLogger.warn(`repeatPromise 发生错误`, err);
            return null;
        }
        finally {
            //清理
            clearTimer();
            UtilLogger_1.SLogger.timeEnd(timeflag);
        }
    }
    UtilFunc.repeatPromise = repeatPromise;
})(UtilFunc = exports.UtilFunc || (exports.UtilFunc = {}));
