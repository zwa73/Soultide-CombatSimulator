import { JToken, PromiseProcFn, PromiseVerifyFn } from "./UtilInterfaces";
/**常用函数 */
export declare namespace UtilFunc {
    /**获取当前时间戳
     * number ()
     * @returns {number} 时间戳
     */
    function getTime(): number;
    /**初始化对象的字段
     * void (Object,string,any)
     * @param {Record<string,T>} obj   - 所要初始化的对象
     * @param {string} field 		   - 所要初始化的字段
     * @param {T} defaultVal 		   - 默认值
     * @returns {T} - 最终值
     */
    function initField<T>(obj: Record<string, T>, field: string, defaultVal: T): T;
    /**生成一串uuid
     * string ()
     * @returns {string} uuid
     */
    function genUUID(): string;
    /**计算Hash
     * string ()
     * @param {string} str - 待计算的字符串
     * @returns {string} hash
     */
    function calcHash(str: string): string;
    /**深克隆 序列化并反序列化
     * @template {T} T - JToken类型的泛型
     * @param {T} obj - 克隆目标
     * @returns {T}   克隆结果
     */
    function deepClone<T extends JToken>(obj: T): T;
    /**是否为安全的数字
     * @param {number} num - 所要检测的数字
     * @returns {boolean} 是否安全
     */
    function isSafeNumber(num: number): boolean;
    /**等待 timeMs 毫秒
     * @async
     * @param {number} timeMs - 等待的毫秒数
     * @returns {Promise<boolean>}
     */
    function sleep(timeMs: number): Promise<boolean>;
    /**封装的 cp.exec 执行一段指令 指令完成后返回 Promise
     * @param {string} command 指令文本
     */
    function exec(command: string): Promise<{
        stdout: string;
        stderr: string;
    }>;
    /**获得一个永不完成的Promise单例 */
    function getNeverResolvedPromise<T>(): Promise<T>;
    /**重复尝试promise
     * @async
     * @param {PromiseProcFn<T>} [procFn]       - 发起函数
     * @param {PromiseVerifyFn<T>} [verifyFn]   - 验证函数
     * @param {number} [repeatCount]    - 重试次数
     * @param {number} [repeatTime]     - 超时时间/秒  最小为10秒
     * @returns {Promise<T|null>}       - 结果 null 为全部失败/超时
     */
    function repeatPromise<T>(procFn: PromiseProcFn<T>, verifyFn?: PromiseVerifyFn<T>, repeatCount?: number, repeatTime?: number): Promise<T | null>;
}
